

Вложенные запросы могут использоваться в операторах соединения `JOIN`.  При этом им необходимо присваивать имя, которое записывается сразу после закрывающей скобки вложенного запроса.

```sql
SELECT
 ...
FROM
    таблица ... JOIN  
       (
        SELECT ...
       ) имя_вложенного_запроса
    ON условие
...
```

Вложенный запрос может стоять как справа, так и слева от оператора `JOIN`. Допускается использование двух запросов в операторах соединения.

**Пример**

Вывести авторов, пишущих книги в самом популярном жанре. Указать этот жанр.

Самым популярным считать жанр, общее количество экземпляров книг которого на складе максимально. Таких жанров может быть несколько, если они имеют одинаковое максимальное значение общего количества экземпляров. Только для этого шага изменена запись в таблице `**book**`.

| **book_id** | **title** | **author_id** | **genre_id** | **price** | **amount** |
| ----------- | --------- | ------------- | ------------ | --------- | ---------- |
| 8           | Лирика    | 4             | 2            | 518.9910  | 10         |

А также добавлены новые записи:

| **book_id** | **title**            | **author_id** | **genre_id** | **price** | **amount** |
| ----------- | -------------------- | ------------- | ------------ | --------- | ---------- |
| 9           | Герой нашего времени | 5             | 3            | 570.59    | 2          |
| 10          | Доктор Живаго        | 4             | 3            | 740.50    | 5          |

Рассмотрим реализацию этого запроса по шагам.

**Шаг 1.** Найдем общее количество книг по каждому жанру, отсортируем его по убыванию и ограничим вывод одной строкой. Рекомендуется, если запрос будет использоваться в качестве вложенного (особенно в операциях соединения), вычисляемым полям запроса давать собственное имя.

_Запрос:_

```sql
SELECT genre_id, SUM(amount) AS sum_amount
FROM book
GROUP BY genre_id
ORDER BY sum_amount DESC
LIMIT 1
```

_Результат:_

```sql
+---------------+------------+
|  genre_id     | sum_amount |
+---------------+------------+
| 1             | 31         |
+---------------+------------+
```

Кажется, что, уже используя этот запрос, можно получить **`id`** самого популярного жанра. Но это не так, поскольку несколько жанров могут иметь одинаковую популярность. Поэтому нам необходим запрос, который отберет ВСЕ жанры, суммарное количество книг которых равно `**sum_amount**`.

**Шаг 2.** Используя запрос с предыдущего шага, найдем `**id**` самых популярных жанров.

_Запрос:_

```sql
SELECT query_in_1.genre_id
FROM 
    (/* выбираем код жанра и количество произведений, относящихся к нему */
      SELECT genre_id, SUM(amount) AS sum_amount
      FROM book
      GROUP BY genre_id 
    )query_in_1
    INNER JOIN
    (/* выбираем запись, в которой указан код жанр с максимальным количеством книг */
      SELECT genre_id, SUM(amount) AS sum_amount
      FROM book
      GROUP BY genre_id
      ORDER BY sum_amount DESC
      LIMIT 1
     ) query_in_2
     ON query_in_1.sum_amount= query_in_2.sum_amount              
  
```

_Результат:_

```sql
+----------+
| genre_id |
+----------+
| 1        |
| 2        |
+----------+
```

**Шаг 3.** Используя запрос с шага 2, выведем фамилии авторов, которые пишут в самых популярных жанрах, и названия этих жанров. В этом запросе обязательно выполнить группировку по фамилиям авторов и `**id**` жанров, так как без этого фамилии авторов будут повторяться, поскольку в таблице **`book`** есть разные книги, написанные автором в одном жанре.

_Запрос:_

```sql
SELECT  name_author, name_genre
FROM 
    author 
    INNER JOIN book ON author.author_id = book.author_id
    INNER JOIN genre ON  book.genre_id = genre.genre_id
GROUP BY name_author,name_genre, genre.genre_id
HAVING genre.genre_id IN
         (/* выбираем автора, если он пишет книги в самых популярных жанрах*/
          SELECT query_in_1.genre_id
          FROM 
              ( /* выбираем код жанра и количество произведений, относящихся к нему */
                SELECT genre_id, SUM(amount) AS sum_amount
                FROM book
                GROUP BY genre_id
               )query_in_1
          INNER JOIN 
              ( /* выбираем запись, в которой указан код жанр с максимальным количеством книг */
                SELECT genre_id, SUM(amount) AS sum_amount
                FROM book
                GROUP BY genre_id
                ORDER BY sum_amount DESC
                LIMIT 1
               ) query_in_2
          ON query_in_1.sum_amount= query_in_2.sum_amount
         );   
```

**Важно!**

1. Обратите внимание, что в группировку включен столбец`**genre_id**`, который используется в `HAVING.` Это связано с тем, что в `HAVING` можно использовать либо столбцы, перечисленные в `GROUP BY`, либо вычисляемые с помощью групповых функций столбцы. Добавление столбца `**genre_id**`не влияет на группировку, так как между названием жанра и его **id** - взаимно-однозначное соответствие.
2. Название столбца `genre_id` задается с указанием имени таблицы (`**genre.genre_id**`), так как этот столбец входит в структуру двух таблиц `**book**` и **`genre`**.  Для этого запроса можно было бы указать и `**book.genre_id**`, так как эти таблицы связаны внутренним соединением `INNER JOIN` и имеют одинаковые значения в полях `**genre.genre_id**` и `**book.genre_id**`.